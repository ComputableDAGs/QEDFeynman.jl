var documenterSearchIndex = {"docs":
[{"location":"#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"QEDFeynman.jl\"]\nOrder = [:module]","category":"page"},{"location":"#QEDFeynman.QEDFeynman","page":"Models","title":"QEDFeynman.QEDFeynman","text":"QEDFeynman\n\nA module containing QED and ABC model functionality for scattering processes in particle physics.\n\n\n\n\n\n","category":"module"},{"location":"#Interface-and-General","page":"Models","title":"Interface and General","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"The interface that has to be implemented for a model to be usable is defined in src/interface.jl.","category":"page"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"interface.jl\"]\nOrder = [:type, :constant, :function]","category":"page"},{"location":"#QEDFeynman.AbstractPhysicsModel","page":"Models","title":"QEDFeynman.AbstractPhysicsModel","text":"AbstractPhysicsModel\n\nBase type for a model, e.g. ABC-Model or QED. This is used to dispatch many functions.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.AbstractProcessDescription","page":"Models","title":"QEDFeynman.AbstractProcessDescription","text":"AbstractProcessDescription <: AbstractProblemInstance\n\nBase type for particle scattering process descriptions. An object of this type of a corresponding AbstractPhysicsModel should uniquely identify a scattering process in that model.\n\nSee also: parse_process\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.AbstractProcessInput","page":"Models","title":"QEDFeynman.AbstractProcessInput","text":"AbstractProcessInput\n\nBase type for process inputs. An object of this type contains the input values (e.g. momenta) of the particles in a process.\n\nSee also: gen_process_input\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ParticleValue","page":"Models","title":"QEDFeynman.ParticleValue","text":"ParticleValue{ParticleType <: AbstractParticleStateful}\n\nA struct describing a particle during a calculation of a Feynman Diagram, together with the value that's being calculated. AbstractParticleStateful is the type from the QEDbase package.\n\nsizeof(ParticleValue()) = 48 Byte\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ParticleValueSP","page":"Models","title":"QEDFeynman.ParticleValueSP","text":"TBW\n\nparticle value + spin/pol info, only used on the external legs (u tasks)\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.gen_process_input","page":"Models","title":"QEDFeynman.gen_process_input","text":"gen_process_input(::AbstractProcessDescription)\n\nInterface function that must be implemented for every specific AbstractProcessDescription. Returns a randomly generated and valid corresponding ProcessInput.\n\n\n\n\n\n","category":"function"},{"location":"#QEDFeynman.get_particle","page":"Models","title":"QEDFeynman.get_particle","text":"get_particle(::AbstractProcessInput, t::Type, n::Int)\n\nInterface function that must be implemented for every subtype of AbstractProcessInput. Returns the nth particle of type t.\n\n\n\n\n\n","category":"function"},{"location":"#QEDFeynman.interaction_result","page":"Models","title":"QEDFeynman.interaction_result","text":"interaction_result(t1::AbstractParticleStateful, t2::AbstractParticleStateful)\n\nInterface function that must be implemented for AbstractParticleStatefuls for all pairs of particle_species that can occur in the model. It should return the result particle (stateful) type when the two given particles interact.\n\n\n\n\n\n","category":"function"},{"location":"#QEDFeynman.model","page":"Models","title":"QEDFeynman.model","text":"model(::AbstractProcessDescription)\nmodel(::AbstractProcessInput)\n\nReturn the model of this process description or input.\n\n\n\n\n\n","category":"function"},{"location":"#QEDFeynman.parse_process","page":"Models","title":"QEDFeynman.parse_process","text":"parse_process(::AbstractString, ::AbstractPhysicsModel)\n\nInterface function that must be implemented for every subtype of AbstractPhysicsModel. Returns a ProcessDescription object.\n\n\n\n\n\n","category":"function"},{"location":"#QEDFeynman.part_from_x-Tuple{Type, Int64, QEDFeynman.AbstractProcessInput}","page":"Models","title":"QEDFeynman.part_from_x","text":"part_from_x(type::Type, index::Int, x::AbstractProcessInput)\n\nReturn the ParticleValue of the given type of particle with the given index from the given process input.\n\nFunction is wrapped into a FunctionCall in gen_input_assignment_code.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.type_index_from_name","page":"Models","title":"QEDFeynman.type_index_from_name","text":"type_from_name(model::AbstractModel, name::String)\n\nFor a name of a particle in the given AbstractModel, return the particle's Type and index as a tuple. The input string can be expetced to be of the form \"<name><index>\".\n\n\n\n\n\n","category":"function"},{"location":"#QEDFeynman.types","page":"Models","title":"QEDFeynman.types","text":"types(::AbstractPhysicsModel)\n\nInterface function that must be implemented for every subtype of AbstractPhysicsModel, returning a Vector of the available particle types in the model.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"impl.jl\"]\nOrder = [:function]","category":"page"},{"location":"#QEDFeynman.propagated_particle-Tuple{QEDbase.AbstractParticleStateful}","page":"Models","title":"QEDFeynman.propagated_particle","text":"propagated_particle(p::AbstractParticleStateful)\n\nReturns the same particle but with inversed particle_direction.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"utility.jl\"]\nOrder = [:function]","category":"page"},{"location":"#ABC-Model","page":"Models","title":"ABC-Model","text":"","category":"section"},{"location":"#Types","page":"Models","title":"Types","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"abc/types.jl\"]\nOrder   = [:type, :constant]","category":"page"},{"location":"#QEDFeynman.ABCModel","page":"Models","title":"QEDFeynman.ABCModel","text":"ABCModel <: AbstractPhysicsModel\n\nSingleton definition for identification of the ABC-Model.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ABCParticle","page":"Models","title":"QEDFeynman.ABCParticle","text":"ABCParticle\n\nBase type for all particles in the ABCModel.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ComputeTaskABC_P","page":"Models","title":"QEDFeynman.ComputeTaskABC_P","text":"ComputeTaskABC_P <: AbstractComputeTask\n\nP task with no children.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ComputeTaskABC_S1","page":"Models","title":"QEDFeynman.ComputeTaskABC_S1","text":"ComputeTaskABC_S1 <: AbstractComputeTask\n\nS task with a single child.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ComputeTaskABC_S2","page":"Models","title":"QEDFeynman.ComputeTaskABC_S2","text":"ComputeTaskABC_S2 <: AbstractComputeTask\n\nS task with two children.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ComputeTaskABC_Sum","page":"Models","title":"QEDFeynman.ComputeTaskABC_Sum","text":"ComputeTaskABC_Sum <: AbstractComputeTask\n\nTask that sums all its inputs, n children.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ComputeTaskABC_U","page":"Models","title":"QEDFeynman.ComputeTaskABC_U","text":"ComputeTaskABC_U <: AbstractComputeTask\n\nu task with a single child.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ComputeTaskABC_V","page":"Models","title":"QEDFeynman.ComputeTaskABC_V","text":"ComputeTaskABC_V <: AbstractComputeTask\n\nv task with two children.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ParticleA","page":"Models","title":"QEDFeynman.ParticleA","text":"ParticleA <: ABCParticle\n\nAn 'A' particle in the ABC Model.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ParticleB","page":"Models","title":"QEDFeynman.ParticleB","text":"ParticleB <: ABCParticle\n\nA 'B' particle in the ABC Model.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ParticleC","page":"Models","title":"QEDFeynman.ParticleC","text":"ParticleC <: ABCParticle\n\nA 'C' particle in the ABC Model.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.PerturbativeABC","page":"Models","title":"QEDFeynman.PerturbativeABC","text":"PerturbativeABC <: AbstractModel\n\nThe model being used for the ABC model.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ABC_TASKS","page":"Models","title":"QEDFeynman.ABC_TASKS","text":"ABC_TASKS\n\nConstant vector of all tasks of the ABC-Model.\n\n\n\n\n\n","category":"constant"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"abc/generic_abc_process.jl\"]\nOrder   = [:type, :function, :constant]","category":"page"},{"location":"#QEDFeynman.GenericABCProcess","page":"Models","title":"QEDFeynman.GenericABCProcess","text":"GenericABCProcess <: AbstractProcessDefinition\n\n\n\n\n\n","category":"type"},{"location":"#Particle","page":"Models","title":"Particle","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"abc/particle.jl\"]\nOrder   = [:type, :constant, :function]","category":"page"},{"location":"#QEDFeynman.ABC_conserve_momentum-Tuple{QEDbase.AbstractParticleStateful{<:QEDbase.ParticleDirection, <:ABCParticle}, QEDbase.AbstractParticleStateful{<:QEDbase.ParticleDirection, <:ABCParticle}}","page":"Models","title":"QEDFeynman.ABC_conserve_momentum","text":"ABC_conserve_momentum(p1::ABCParticle, p2::ABCParticle)\n\nCalculate and return a new particle from two given interacting ones at a vertex.\n\nTakes 4 effective FLOP.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.ABC_inner_edge-Tuple{QEDbase.AbstractParticleStateful{<:QEDbase.ParticleDirection, <:ABCParticle}}","page":"Models","title":"QEDFeynman.ABC_inner_edge","text":"ABC_inner_edge(p::AbstractParticleStateful{Dir, ABCParticle})\n\nReturn the factor of the inner edge with the given (virtual) particle.\n\nTakes 10 effective FLOP. (3 here + 7 in square(p))\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.ABC_outer_edge-Union{Tuple{QEDbase.AbstractParticleStateful{D, <:ABCParticle}}, Tuple{D}} where D","page":"Models","title":"QEDFeynman.ABC_outer_edge","text":"ABC_outer_edge(p::AbstractParticleStateful{Dir, ABCParticle})\n\nReturn the factor of the outer edge with the given (real) particle.\n\nTakes 0 effective FLOP.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.ABC_vertex-Tuple{}","page":"Models","title":"QEDFeynman.ABC_vertex","text":"ABC_vertex()\n\nReturn the factor of a vertex.\n\nTakes 0 effective FLOP since it's constant.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.interaction_result-Tuple{QEDbase.AbstractParticleStateful{<:QEDbase.ParticleDirection, <:ABCParticle}, QEDbase.AbstractParticleStateful{<:QEDbase.ParticleDirection, <:ABCParticle}}","page":"Models","title":"QEDFeynman.interaction_result","text":"interaction_result(\n    p1::AbstractParticleStateful{<:ParticleDirection, <:ABCParticle},\n    p2::AbstractParticleStateful{<:ParticleDirection, <:ABCParticle},\n)\n\nFor 2 given (non-equal) particle types, return the third of ABC.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.square-Tuple{QEDbase.AbstractParticleStateful{<:QEDbase.ParticleDirection, <:ABCParticle}}","page":"Models","title":"QEDFeynman.square","text":"square(p::AbstractParticleStateful{Dir, ABCParticle})\n\nReturn the square of the particle's momentum as a Float value.\n\nTakes 7 effective FLOP.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.types-Tuple{ABCModel}","page":"Models","title":"QEDFeynman.types","text":"types(::ABCModel)\n\nReturn a Vector of the possible types of particle in the ABCModel.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.mass-Tuple{ABCParticle}","page":"Models","title":"QEDbase.mass","text":"mass(t::Type{T}) where {T <: ABCParticle}\n\nReturn the mass (at rest) of the given particle type.\n\n\n\n\n\n","category":"method"},{"location":"#Parse","page":"Models","title":"Parse","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"abc/parse.jl\"]\nOrder   = [:function]","category":"page"},{"location":"#QEDFeynman.parse_dag","page":"Models","title":"QEDFeynman.parse_dag","text":"parse_dag(filename::String, proc::GenericABCProcess; verbose::Bool = false)\n\nRead an ABC-model process from the given file. If verbose is set to true, print some progress information to stdout.\n\nReturns a valid DAG.\n\n\n\n\n\n","category":"function"},{"location":"#QEDFeynman.parse_edges-Tuple{AbstractString}","page":"Models","title":"QEDFeynman.parse_edges","text":"parse_edges(input::AbstractString)\n\nParse the given string into a vector of strings containing each edge. Currently unused since the entire graph can be read from just the node names.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.parse_nodes-Tuple{AbstractString}","page":"Models","title":"QEDFeynman.parse_nodes","text":"parse_nodes(input::AbstractString)\n\nParse the given string into a vector of strings containing each node.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.parse_process-Tuple{AbstractString, ABCModel}","page":"Models","title":"QEDFeynman.parse_process","text":"parse_process(string::AbstractString, model::ABCModel)\n\nParse a string representation of a process, such as \"AB->ABBB\" into the corresponding GenericABCProcess.\n\n\n\n\n\n","category":"method"},{"location":"#Properties","page":"Models","title":"Properties","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"abc/properties.jl\"]\nOrder   = [:function]","category":"page"},{"location":"#ComputableDAGs.children-Tuple{ComputeTaskABC_P}","page":"Models","title":"ComputableDAGs.children","text":"children(::ComputeTaskABC_P)\n\nReturn the number of children of a ComputeTaskABC_P (always 1).\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.children-Tuple{ComputeTaskABC_S1}","page":"Models","title":"ComputableDAGs.children","text":"children(::ComputeTaskABC_S1)\n\nReturn the number of children of a ComputeTaskABC_S1 (always 1).\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.children-Tuple{ComputeTaskABC_S2}","page":"Models","title":"ComputableDAGs.children","text":"children(::ComputeTaskABC_S2)\n\nReturn the number of children of a ComputeTaskABC_S2 (always 2).\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.children-Tuple{ComputeTaskABC_Sum}","page":"Models","title":"ComputableDAGs.children","text":"children(::ComputeTaskABC_Sum)\n\nReturn the number of children of a ComputeTaskABC_Sum.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.children-Tuple{ComputeTaskABC_U}","page":"Models","title":"ComputableDAGs.children","text":"children(::ComputeTaskABC_U)\n\nReturn the number of children of a ComputeTaskABC_U (always 1).\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.children-Tuple{ComputeTaskABC_V}","page":"Models","title":"ComputableDAGs.children","text":"children(::ComputeTaskABC_V)\n\nReturn the number of children of a ComputeTaskABC_V (always 2).\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute_effort-Tuple{ComputeTaskABC_P}","page":"Models","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::ComputeTaskABC_P)\n\nReturn the compute effort of a P task.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute_effort-Tuple{ComputeTaskABC_S1}","page":"Models","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::ComputeTaskABC_S1)\n\nReturn the compute effort of an S1 task.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute_effort-Tuple{ComputeTaskABC_S2}","page":"Models","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::ComputeTaskABC_S2)\n\nReturn the compute effort of an S2 task.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute_effort-Tuple{ComputeTaskABC_Sum}","page":"Models","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::ComputeTaskABC_Sum)\n\nReturn the compute effort of a Sum task. \n\nNote: This is a constant compute effort, even though sum scales with the number of its inputs. Since there is only ever a single sum node in a graph generated from the ABC-Model, this doesn't matter.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute_effort-Tuple{ComputeTaskABC_U}","page":"Models","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::ComputeTaskABC_U)\n\nReturn the compute effort of a U task.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute_effort-Tuple{ComputeTaskABC_V}","page":"Models","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::ComputeTaskABC_V)\n\nReturn the compute effort of a V task.\n\n\n\n\n\n","category":"method"},{"location":"#Create","page":"Models","title":"Create","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"abc/create.jl\"]\nOrder = [:function]","category":"page"},{"location":"#QEDFeynman.gen_process_input-Tuple{GenericABCProcess}","page":"Models","title":"QEDFeynman.gen_process_input","text":"gen_process_input(proc::GenericABCProcess)\n\nReturn a ProcessInput of randomly generated ABCParticles from a GenericABCProcess. The process description can be created manually or parsed from a string using parse_process.\n\nNote: This uses RAMBO to create a valid process with conservation of momentum and energy.\n\n\n\n\n\n","category":"method"},{"location":"#Compute","page":"Models","title":"Compute","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"abc/compute.jl\"]\nOrder = [:function]","category":"page"},{"location":"#ComputableDAGs.compute-Tuple{ComputeTaskABC_Sum, Vararg{Any}}","page":"Models","title":"ComputableDAGs.compute","text":"compute(::ComputeTaskABC_Sum, data...)\ncompute(::ComputeTaskABC_Sum, data::AbstractArray)\n\nCompute a sum over the vector. Use an algorithm that accounts for accumulated errors in long sums with potentially large differences in magnitude of the summands.\n\nLinearly many FLOP with growing data.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute-Union{Tuple{P2}, Tuple{P1}, Tuple{ComputeTaskABC_V, ParticleValue{P1}, ParticleValue{P2}}} where {P1, P2}","page":"Models","title":"ComputableDAGs.compute","text":"compute(::ComputeTaskABC_V, data1::ParticleValue, data2::ParticleValue)\n\nCompute a vertex. Preserve momentum and particle types (AB->C etc.) to create resulting particle, multiply values together and times a vertex factor.\n\n6 FLOP.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute-Union{Tuple{P}, Tuple{ComputeTaskABC_P, ParticleValue{P}}} where P","page":"Models","title":"ComputableDAGs.compute","text":"compute(::ComputeTaskABC_P, data::ParticleValue)\n\nReturn the particle and value as is. \n\n0 FLOP.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute-Union{Tuple{P}, Tuple{ComputeTaskABC_S1, ParticleValue{P}}} where P","page":"Models","title":"ComputableDAGs.compute","text":"compute(::ComputeTaskABC_S1, data::ParticleValue)\n\nCompute inner edge (1 input particle, 1 output particle).\n\n11 FLOP.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute-Union{Tuple{P}, Tuple{ComputeTaskABC_S2, ParticleValue{P}, ParticleValue{P}}} where P","page":"Models","title":"ComputableDAGs.compute","text":"compute(::ComputeTaskABC_S2, data1::ParticleValue, data2::ParticleValue)\n\nCompute a final inner edge (2 input particles, no output particle).\n\nFor valid inputs, both input particles should have the same momenta at this point.\n\n12 FLOP.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute-Union{Tuple{P}, Tuple{ComputeTaskABC_U, ParticleValue{P}}} where P","page":"Models","title":"ComputableDAGs.compute","text":"compute(::ComputeTaskABC_U, data::ParticleValue)\n\nCompute an outer edge. Return the particle value with the same particle and the value multiplied by an ABCouteredge factor.\n\n1 FLOP.\n\n\n\n\n\n","category":"method"},{"location":"#Print","page":"Models","title":"Print","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"abc/print.jl\"]\nOrder = [:function]","category":"page"},{"location":"#QEDFeynman.show-Tuple{IO, ABCParticle}","page":"Models","title":"QEDFeynman.show","text":"show(io::IO, particle::ABCParticle)\n\nPretty print an ABCParticle (no newlines).\n\n\n\n\n\n","category":"method"},{"location":"#QED-Model","page":"Models","title":"QED-Model","text":"","category":"section"},{"location":"#Feynman-Diagrams","page":"Models","title":"Feynman Diagrams","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"qed/diagrams.jl\"]\nOrder   = [:type, :function, :constant]","category":"page"},{"location":"#Core.String-Tuple{FeynmanParticle}","page":"Models","title":"Core.String","text":"String(p::FeynmanParticle)\n\nReturn a string representation of the FeynmanParticle in a format that is readable by type_index_from_name.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.FeynmanDiagram","page":"Models","title":"QEDFeynman.FeynmanDiagram","text":"FeynmanDiagram\n\nRepresentation of a feynman diagram. It consists of its initial input/output particles, and a vector of sets of FeynmanVertexs. The vertices are to be applied level by level. A FeynmanVertex will always be at the lowest level possible, i.e. the lowest level at which all input particles for it exist. The FeynmanTie represents the final inner edge of the diagram.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.FeynmanDiagram-Tuple{QEDprocesses.ScatteringProcess}","page":"Models","title":"QEDFeynman.FeynmanDiagram","text":"FeynmanDiagram(pd::ScatteringProcess)\n\nCreate an initial FeynmanDiagram with only its initial particles set and no vertices or ties.\n\nUse gen_diagrams to generate all possible diagrams from this one.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.FeynmanParticle","page":"Models","title":"QEDFeynman.FeynmanParticle","text":"FeynmanParticle\n\nRepresentation of a particle for use in FeynmanDiagrams. Consist of the ParticleStateful type and an id.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.FeynmanTie","page":"Models","title":"QEDFeynman.FeynmanTie","text":"FeynmanTie\n\nRepresentation of a \"tie\" in a FeynmanDiagram. A tie ties two virtual particles in a diagram together and thus represent an inner line of the diagram. Not all inner lines are FeynmanTies, in fact, a connected diagram only ever has exactly one tie.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.FeynmanVertex","page":"Models","title":"QEDFeynman.FeynmanVertex","text":"FeynmanVertex\n\nRepresentation of a vertex in a FeynmanDiagram. Stores two input FeynmanParticles and one output.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.add_tie!-Tuple{FeynmanDiagram, FeynmanTie}","page":"Models","title":"QEDFeynman.add_tie!","text":"add_tie!(fd::FeynmanDiagram, tie::FeynmanTie)\n\nAdd the given tie to the diagram, always at the last level.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.add_tie-Tuple{FeynmanDiagram, FeynmanTie}","page":"Models","title":"QEDFeynman.add_tie","text":"add_tie(fd::FeynmanDiagram, tie::FeynmanTie)\n\nAdd the given tie to the diagram, at the earliest level possible. Return the new diagram without muting the given one.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.add_vertex!-Tuple{FeynmanDiagram, FeynmanVertex}","page":"Models","title":"QEDFeynman.add_vertex!","text":"add_vertex!(fd::FeynmanDiagram, vertex::FeynmanVertex)\n\nAdd the given vertex to the diagram, at the earliest level possible.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.add_vertex-Tuple{FeynmanDiagram, FeynmanVertex}","page":"Models","title":"QEDFeynman.add_vertex","text":"add_vertex(fd::FeynmanDiagram, vertex::FeynmanVertex)\n\nAdd the given vertex to the diagram, at the earliest level possible. Return the new diagram without muting the given one.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.apply_tie!-Tuple{Vector{FeynmanParticle}, FeynmanTie}","page":"Models","title":"QEDFeynman.apply_tie!","text":"apply_tie!(particles::Vector{FeynmanParticle}, tie::FeynmanTie)\n\nApply a FeynmanTie to the given vector of FeynmanParticles.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.apply_vertex!-Tuple{Vector{FeynmanParticle}, FeynmanVertex}","page":"Models","title":"QEDFeynman.apply_vertex!","text":"apply_vertex!(particles::Vector{FeynmanParticle}, vertex::FeynmanVertex)\n\nApply a FeynmanVertex to the given vector of FeynmanParticles.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.can_apply_tie-Tuple{Vector{FeynmanParticle}, FeynmanTie}","page":"Models","title":"QEDFeynman.can_apply_tie","text":"can_apply_tie(particles::Vector{FeynmanParticle}, tie::FeynmanTie)\n\nReturn true if the given FeynmanTie can be applied to the given particles, i.e. both input particles of the tie are in the vector.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.can_apply_vertex-Tuple{Vector{FeynmanParticle}, FeynmanVertex}","page":"Models","title":"QEDFeynman.can_apply_vertex","text":"can_apply_vertex(particles::Vector{FeynmanParticle}, vertex::FeynmanVertex)\n\nReturn true if the given FeynmanVertex can be applied to the given particles, i.e. both input particles of the vertex are in the vector and the output particle is not.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.can_tie-Tuple{Type, Type}","page":"Models","title":"QEDFeynman.can_tie","text":"can_tie(p1::Type, p2::Type)\n\nFor two given QEDParticle types, return whether they can be tied together.\n\nThey can be tied iff one is the propagation_result of the other, or if both are photons, in which case their direction does not matter.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.gen_compton_diagram_from_order-Tuple{Vector{Int64}, Any, Any, Int64, Int64}","page":"Models","title":"QEDFeynman.gen_compton_diagram_from_order","text":"gen_compton_diagram_from_order(order::Vector{Int}, inFerm, outFerm, n::Int, m::Int)\n\nHelper function for gen_compton_diagrams. Generates a single diagram for the given order and n input and m output photons.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.gen_compton_diagram_from_order_one_side-Tuple{Vector{Int64}, Any, Any, Int64, Int64}","page":"Models","title":"QEDFeynman.gen_compton_diagram_from_order_one_side","text":"gen_compton_diagram_from_order_one_side(order::Vector{Int}, inFerm, outFerm, n::Int, m::Int)\n\nHelper function for gen_compton_diagrams. Generates a single diagram for the given order and n input and m output photons.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.gen_compton_diagrams-Tuple{Int64, Int64}","page":"Models","title":"QEDFeynman.gen_compton_diagrams","text":"gen_compton_diagrams(n::Int, m::Int)\n\nSpecial case diagram generation for Compton processes, i.e., processes of the form k^ne->k^me\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.gen_compton_diagrams_one_side-Tuple{Int64, Int64}","page":"Models","title":"QEDFeynman.gen_compton_diagrams_one_side","text":"gen_compton_diagrams_one_side(n::Int, m::Int)\n\nSpecial case diagram generation for Compton processes, i.e., processes of the form k^ne->k^me, but generating from one end, yielding larger diagrams\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.gen_diagrams-Tuple{FeynmanDiagram}","page":"Models","title":"QEDFeynman.gen_diagrams","text":"gen_diagrams(fd::FeynmanDiagram)\n\nFrom a given feynman diagram in its initial state, e.g. when created through the FeynmanDiagram(pd::ProcessDescription) constructor, generate and return all possible FeynmanDiagrams that describe that process.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.get_particles","page":"Models","title":"QEDFeynman.get_particles","text":"get_particles(fd::FeynmanDiagram, level::Int)\n\nReturn a vector of the particles after applying the vertices and tie of the diagram up to the given level. If no level is given, apply all. The tie comes last and is its own \"level\".\n\n\n\n\n\n","category":"function"},{"location":"#QEDFeynman.id_for_type-Tuple{FeynmanDiagram, Type{<:QEDcore.ParticleStateful}}","page":"Models","title":"QEDFeynman.id_for_type","text":"id_for_type(d::FeynmanDiagram, t::Type{<:ParticleStateful})\n\nReturn the highest id of any particle of the given type in the diagram + 1.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.is_compton-Tuple{FeynmanDiagram}","page":"Models","title":"QEDFeynman.is_compton","text":"is_compton(fd::FeynmanDiagram)\n\nReturns true iff the given feynman diagram is an (empty) diagram of a compton process like ke->k^ne\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.isvalid-Tuple{FeynmanDiagram}","page":"Models","title":"QEDFeynman.isvalid","text":"isvalid(fd::FeynmanDiagram)\n\nReturn whether the given diagram is valid. A diagram is valid iff the following are true:\n\nAfter applying all vertices and the tie, there are no more particles left\nThe diagram is connected\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.possible_tie-Tuple{FeynmanDiagram}","page":"Models","title":"QEDFeynman.possible_tie","text":"possible_tie(fd::FeynmanDiagram)\n\nReturn a possible tie or missing for the diagram at its current state.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.possible_vertices-Tuple{FeynmanDiagram}","page":"Models","title":"QEDFeynman.possible_vertices","text":"possible_vertices(fd::FeynmanDiagram)\n\nReturn a vector of all possible vertices that can be applied to the diagram at its current state.\n\n\n\n\n\n","category":"method"},{"location":"#Types-2","page":"Models","title":"Types","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"qed/types.jl\"]\nOrder   = [:type, :constant]","category":"page"},{"location":"#QEDFeynman.ComputeTaskQED_P","page":"Models","title":"QEDFeynman.ComputeTaskQED_P","text":"ComputeTaskQED_P <: AbstractComputeTask\n\nP task with no children.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ComputeTaskQED_S1","page":"Models","title":"QEDFeynman.ComputeTaskQED_S1","text":"ComputeTaskQED_S1 <: AbstractComputeTask\n\nS task with a single child.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ComputeTaskQED_S2","page":"Models","title":"QEDFeynman.ComputeTaskQED_S2","text":"ComputeTaskQED_S2 <: AbstractComputeTask\n\nS task with two children.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ComputeTaskQED_Sum","page":"Models","title":"QEDFeynman.ComputeTaskQED_Sum","text":"ComputeTaskQED_Sum <: AbstractComputeTask\n\nTask that sums all its inputs, n children.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ComputeTaskQED_U","page":"Models","title":"QEDFeynman.ComputeTaskQED_U","text":"ComputeTaskQED_U <: AbstractComputeTask\n\nu task with a single child.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.ComputeTaskQED_V","page":"Models","title":"QEDFeynman.ComputeTaskQED_V","text":"ComputeTaskQED_V <: AbstractComputeTask\n\nv task with two children.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.QEDModel","page":"Models","title":"QEDFeynman.QEDModel","text":"QEDModel <: AbstractPhysicsModel\n\nSingleton definition for identification of the QED-Model.\n\n\n\n\n\n","category":"type"},{"location":"#QEDFeynman.QED_TASKS","page":"Models","title":"QEDFeynman.QED_TASKS","text":"QED_TASKS\n\nConstant vector of all tasks of the QED-Model.\n\n\n\n\n\n","category":"constant"},{"location":"#Particle-2","page":"Models","title":"Particle","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"qed/particle.jl\"]\nOrder   = [:type, :constant, :function]","category":"page"},{"location":"#QEDFeynman.QED_conserve_momentum-Tuple{QEDbase.AbstractParticleStateful, QEDbase.AbstractParticleStateful}","page":"Models","title":"QEDFeynman.QED_conserve_momentum","text":"QED_conserve_momentum(p1::ParticleStateful, p2::ParticleStateful)\n\nCalculate and return a new particle from two given interacting ones at a vertex.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.QED_vertex-Tuple{}","page":"Models","title":"QEDFeynman.QED_vertex","text":"QED_vertex()\n\nReturn the factor of a vertex in a QED feynman diagram.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.caninteract-Union{Tuple{S2}, Tuple{D2}, Tuple{S1}, Tuple{D1}, Tuple{Type{<:QEDcore.ParticleStateful{D1, S1}}, Type{<:QEDcore.ParticleStateful{D2, S2}}}} where {D1<:QEDbase.ParticleDirection, S1<:QEDbase.AbstractParticleType, D2<:QEDbase.ParticleDirection, S2<:QEDbase.AbstractParticleType}","page":"Models","title":"QEDFeynman.caninteract","text":"caninteract(T1::Type{<:ParticleStateful}, T2::Type{<:ParticleStateful})\n\nFor two given ParticleStateful types, return whether they can interact at a vertex. This is equivalent to !issame(T1, T2).\n\nSee also: issame and interaction_result\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.issame-Tuple{Type{<:QEDcore.ParticleStateful}, Type{<:QEDcore.ParticleStateful}}","page":"Models","title":"QEDFeynman.issame","text":"issame(T1::Type{<:ParticleStateful}, T2::Type{<:ParticleStateful})\n\nFor two given ParticleStateful types, return whether they are equivalent for the purpose of a Feynman Diagram. That means e.g. an Incoming AntiFermion is the same as an Outgoing Fermion. This is equivalent to !caninteract(T1, T2).\n\nSee also: caninteract and interaction_result\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.model-Tuple{QEDprocesses.ScatteringProcess}","page":"Models","title":"QEDFeynman.model","text":"model(::AbstractProcessDescription)\n\nReturn the model of this process description.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.types-Tuple{QEDModel}","page":"Models","title":"QEDFeynman.types","text":"types(::QEDModel)\n\nReturn a Vector of the possible types of particle in the QEDModel.\n\n\n\n\n\n","category":"method"},{"location":"#Parse-2","page":"Models","title":"Parse","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"qed/parse.jl\"]\nOrder   = [:function]","category":"page"},{"location":"#QEDFeynman.parse_process-2","page":"Models","title":"QEDFeynman.parse_process","text":"parse_process(string::AbstractString, model::QEDModel)\n\nParse a string representation of a process, such as \"ke->ke\" into the corresponding QEDProcessDescription.\n\n\n\n\n\n","category":"function"},{"location":"#Properties-2","page":"Models","title":"Properties","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"qed/properties.jl\"]\nOrder   = [:function]","category":"page"},{"location":"#ComputableDAGs.children-Tuple{ComputeTaskQED_P}","page":"Models","title":"ComputableDAGs.children","text":"children(::ComputeTaskQED_P)\n\nReturn the number of children of a ComputeTaskQED_P (always 1).\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.children-Tuple{ComputeTaskQED_S1}","page":"Models","title":"ComputableDAGs.children","text":"children(::ComputeTaskQED_S1)\n\nReturn the number of children of a ComputeTaskQED_S1 (always 1).\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.children-Tuple{ComputeTaskQED_S2}","page":"Models","title":"ComputableDAGs.children","text":"children(::ComputeTaskQED_S2)\n\nReturn the number of children of a ComputeTaskQED_S2 (always 2).\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.children-Tuple{ComputeTaskQED_Sum}","page":"Models","title":"ComputableDAGs.children","text":"children(::ComputeTaskQED_Sum)\n\nReturn the number of children of a ComputeTaskQED_Sum.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.children-Tuple{ComputeTaskQED_U}","page":"Models","title":"ComputableDAGs.children","text":"children(::ComputeTaskQED_U)\n\nReturn the number of children of a ComputeTaskQED_U (always 1).\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.children-Tuple{ComputeTaskQED_V}","page":"Models","title":"ComputableDAGs.children","text":"children(::ComputeTaskQED_V)\n\nReturn the number of children of a ComputeTaskQED_V (always 2).\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute_effort-Tuple{ComputeTaskQED_P}","page":"Models","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::ComputeTaskQED_P)\n\nReturn the compute effort of a P task.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute_effort-Tuple{ComputeTaskQED_S1}","page":"Models","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::ComputeTaskQED_S1)\n\nReturn the compute effort of an S1 task.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute_effort-Tuple{ComputeTaskQED_S2}","page":"Models","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::ComputeTaskQED_S2)\n\nReturn the compute effort of an S2 task.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute_effort-Tuple{ComputeTaskQED_Sum}","page":"Models","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::ComputeTaskQED_Sum)\n\nReturn the compute effort of a Sum task. \n\nNote: This is a constant compute effort, even though sum scales with the number of its inputs. Since there is only ever a single sum node in a graph generated from the QED-Model, this doesn't matter.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute_effort-Tuple{ComputeTaskQED_U}","page":"Models","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::ComputeTaskQED_U)\n\nReturn the compute effort of a U task.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute_effort-Tuple{ComputeTaskQED_V}","page":"Models","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::ComputeTaskQED_V)\n\nReturn the compute effort of a V task.\n\n\n\n\n\n","category":"method"},{"location":"#Create-2","page":"Models","title":"Create","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"qed/create.jl\"]\nOrder = [:function]","category":"page"},{"location":"#QEDFeynman.gen_graph-Tuple{QEDprocesses.ScatteringProcess}","page":"Models","title":"QEDFeynman.gen_graph","text":"gen_graph(process_description::ScatteringProcess)\n\nFor a given QEDprocesses.ScatteringProcess, return the DAG that computes it.\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.gen_process_input-Tuple{QEDprocesses.ScatteringProcess}","page":"Models","title":"QEDFeynman.gen_process_input","text":"gen_process_input(processDescription::ScatteringProcess)\n\nReturn a PhaseSpacePoint of randomly generated particles from a QEDprocesses.ScatteringProcess. The process description can be created manually or parsed from a string using parse_process.\n\nNote: This uses RAMBO to create a valid process with conservation of momentum and energy.\n\n\n\n\n\n","category":"method"},{"location":"#Compute-2","page":"Models","title":"Compute","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"qed/compute.jl\"]\nOrder = [:function]","category":"page"},{"location":"#ComputableDAGs.compute-Tuple{ComputeTaskQED_Sum, Vararg{Any}}","page":"Models","title":"ComputableDAGs.compute","text":"compute(::ComputeTaskQED_Sum, data...)\ncompute(::ComputeTaskQED_Sum, data::AbstractArray)\n\nCompute a sum over the vector. Use an algorithm that accounts for accumulated errors in long sums with potentially large differences in magnitude of the summands.\n\nLinearly many FLOP with growing data.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute-Union{Tuple{P2}, Tuple{P1}, Tuple{EL}, Tuple{V2}, Tuple{V1}, Tuple{S2}, Tuple{S1}, Tuple{D2}, Tuple{D1}, Tuple{ComputeTaskQED_S2, ParticleValue{P1, V1}, ParticleValue{P2, V2}}} where {D1<:QEDbase.ParticleDirection, D2<:QEDbase.ParticleDirection, S1<:Union{QEDcore.Electron, QEDcore.Positron}, S2<:Union{QEDcore.Electron, QEDcore.Positron}, V1<:Union{QEDcore.AdjointBiSpinor, QEDcore.BiSpinor, QEDcore.DiracMatrix, QEDcore.SLorentzVector{Float64}, ComplexF64}, V2<:Union{QEDcore.AdjointBiSpinor, QEDcore.BiSpinor, QEDcore.DiracMatrix, QEDcore.SLorentzVector{Float64}, ComplexF64}, EL<:QEDbase.AbstractFourMomentum, P1<:QEDcore.ParticleStateful{D1, S1, EL}, P2<:QEDcore.ParticleStateful{D2, S2, EL}}","page":"Models","title":"ComputableDAGs.compute","text":"compute(::ComputeTaskQED_S2, data1::ParticleValue, data2::ParticleValue)\n\nCompute a final inner edge (2 input particles, no output particle).\n\nFor valid inputs, both input particles should have the same momenta at this point.\n\n12 FLOP.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute-Union{Tuple{SP}, Tuple{V}, Tuple{P}, Tuple{ComputeTaskQED_U, ParticleValueSP{P, SP, V}}} where {P<:QEDcore.ParticleStateful, V<:Union{QEDcore.AdjointBiSpinor, QEDcore.BiSpinor, QEDcore.DiracMatrix, QEDcore.SLorentzVector{Float64}, ComplexF64}, SP<:QEDbase.AbstractSpinOrPolarization}","page":"Models","title":"ComputableDAGs.compute","text":"compute(::ComputeTaskQED_U, data::ParticleValueSP)\n\nCompute an outer edge. Return the particle value with the same particle and the value multiplied by an outer_edge factor.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute-Union{Tuple{V2}, Tuple{V1}, Tuple{P2}, Tuple{P1}, Tuple{ComputeTaskQED_V, ParticleValue{P1, V1}, ParticleValue{P2, V2}}} where {P1<:QEDcore.ParticleStateful, P2<:QEDcore.ParticleStateful, V1<:Union{QEDcore.AdjointBiSpinor, QEDcore.BiSpinor, QEDcore.DiracMatrix, QEDcore.SLorentzVector{Float64}, ComplexF64}, V2<:Union{QEDcore.AdjointBiSpinor, QEDcore.BiSpinor, QEDcore.DiracMatrix, QEDcore.SLorentzVector{Float64}, ComplexF64}}","page":"Models","title":"ComputableDAGs.compute","text":"compute(::ComputeTaskQED_V, data1::ParticleValue, data2::ParticleValue)\n\nCompute a vertex. Preserve momentum and particle types (e + gamma->p etc.) to create resulting particle, multiply values together and times a vertex factor.\n\n\n\n\n\n","category":"method"},{"location":"#ComputableDAGs.compute-Union{Tuple{V}, Tuple{P}, Tuple{ComputeTaskQED_S1, ParticleValue{P, V}}} where {P<:QEDcore.ParticleStateful, V<:Union{QEDcore.AdjointBiSpinor, QEDcore.BiSpinor, QEDcore.DiracMatrix, QEDcore.SLorentzVector{Float64}, ComplexF64}}","page":"Models","title":"ComputableDAGs.compute","text":"compute(::ComputeTaskQED_S1, data::ParticleValue)\n\nCompute inner edge (1 input particle, 1 output particle).\n\n\n\n\n\n","category":"method"},{"location":"#Print-2","page":"Models","title":"Print","text":"","category":"section"},{"location":"","page":"Models","title":"Models","text":"Modules = [QEDFeynman]\nPages = [\"qed/print.jl\"]\nOrder = [:function]","category":"page"},{"location":"#QEDFeynman.show-Tuple{IO, FeynmanDiagram}","page":"Models","title":"QEDFeynman.show","text":"show(io::IO, particle::FeynmanDiagram)\n\nPretty print a FeynmanDiagram (with newlines).\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.show-Tuple{IO, FeynmanParticle}","page":"Models","title":"QEDFeynman.show","text":"show(io::IO, particle::FeynmanParticle)\n\nPretty print a FeynmanParticle (no newlines).\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.show-Tuple{IO, FeynmanTie}","page":"Models","title":"QEDFeynman.show","text":"show(io::IO, particle::FeynmanTie)\n\nPretty print a FeynmanTie (no newlines).\n\n\n\n\n\n","category":"method"},{"location":"#QEDFeynman.show-Tuple{IO, FeynmanVertex}","page":"Models","title":"QEDFeynman.show","text":"show(io::IO, particle::FeynmanVertex)\n\nPretty print a FeynmanVertex (no newlines).\n\n\n\n\n\n","category":"method"}]
}
